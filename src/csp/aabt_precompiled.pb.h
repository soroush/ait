// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aabt_precompiled.proto

#ifndef PROTOBUF_aabt_5fprecompiled_2eproto__INCLUDED
#define PROTOBUF_aabt_5fprecompiled_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace AIT {
namespace protocols {
namespace csp {
namespace aabt {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();

class P_Assignment;
class P_CompoundAssignment;
class P_NoGood;
class P_Explanation;
class P_CVOrderData;
class P_Message;

enum P_MessageType {
  T_OK = 1,
  T_NOGOOD = 2,
  T_ORDER = 3,
  T_STOP = 4
};
bool P_MessageType_IsValid(int value);
const P_MessageType P_MessageType_MIN = T_OK;
const P_MessageType P_MessageType_MAX = T_STOP;
const int P_MessageType_ARRAYSIZE = P_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* P_MessageType_descriptor();
inline const ::std::string& P_MessageType_Name(P_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    P_MessageType_descriptor(), value);
}
inline bool P_MessageType_Parse(
    const ::std::string& name, P_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<P_MessageType>(
    P_MessageType_descriptor(), name, value);
}
// ===================================================================

class P_Assignment : public ::google::protobuf::Message {
 public:
  P_Assignment();
  virtual ~P_Assignment();
  
  P_Assignment(const P_Assignment& from);
  
  inline P_Assignment& operator=(const P_Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Assignment& default_instance();
  
  void Swap(P_Assignment* other);
  
  // implements Message ----------------------------------------------
  
  P_Assignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Assignment& from);
  void MergeFrom(const P_Assignment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // required int32 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_Assignment)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 time_stamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_Assignment* default_instance_;
};
// -------------------------------------------------------------------

class P_CompoundAssignment : public ::google::protobuf::Message {
 public:
  P_CompoundAssignment();
  virtual ~P_CompoundAssignment();
  
  P_CompoundAssignment(const P_CompoundAssignment& from);
  
  inline P_CompoundAssignment& operator=(const P_CompoundAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_CompoundAssignment& default_instance();
  
  void Swap(P_CompoundAssignment* other);
  
  // implements Message ----------------------------------------------
  
  P_CompoundAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_CompoundAssignment& from);
  void MergeFrom(const P_CompoundAssignment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .AIT.protocols.csp.aabt.P_Assignment assignments = 1;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 1;
  inline const ::AIT::protocols::csp::aabt::P_Assignment& assignments(int index) const;
  inline ::AIT::protocols::csp::aabt::P_Assignment* mutable_assignments(int index);
  inline ::AIT::protocols::csp::aabt::P_Assignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Assignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Assignment >*
      mutable_assignments();
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_CompoundAssignment)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Assignment > assignments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_CompoundAssignment* default_instance_;
};
// -------------------------------------------------------------------

class P_NoGood : public ::google::protobuf::Message {
 public:
  P_NoGood();
  virtual ~P_NoGood();
  
  P_NoGood(const P_NoGood& from);
  
  inline P_NoGood& operator=(const P_NoGood& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_NoGood& default_instance();
  
  void Swap(P_NoGood* other);
  
  // implements Message ----------------------------------------------
  
  P_NoGood* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_NoGood& from);
  void MergeFrom(const P_NoGood& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .AIT.protocols.csp.aabt.P_CompoundAssignment lhs = 1;
  inline bool has_lhs() const;
  inline void clear_lhs();
  static const int kLhsFieldNumber = 1;
  inline const ::AIT::protocols::csp::aabt::P_CompoundAssignment& lhs() const;
  inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* mutable_lhs();
  inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* release_lhs();
  
  // required .AIT.protocols.csp.aabt.P_Assignment rhs = 2;
  inline bool has_rhs() const;
  inline void clear_rhs();
  static const int kRhsFieldNumber = 2;
  inline const ::AIT::protocols::csp::aabt::P_Assignment& rhs() const;
  inline ::AIT::protocols::csp::aabt::P_Assignment* mutable_rhs();
  inline ::AIT::protocols::csp::aabt::P_Assignment* release_rhs();
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_NoGood)
 private:
  inline void set_has_lhs();
  inline void clear_has_lhs();
  inline void set_has_rhs();
  inline void clear_has_rhs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::AIT::protocols::csp::aabt::P_CompoundAssignment* lhs_;
  ::AIT::protocols::csp::aabt::P_Assignment* rhs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_NoGood* default_instance_;
};
// -------------------------------------------------------------------

class P_Explanation : public ::google::protobuf::Message {
 public:
  P_Explanation();
  virtual ~P_Explanation();
  
  P_Explanation(const P_Explanation& from);
  
  inline P_Explanation& operator=(const P_Explanation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Explanation& default_instance();
  
  void Swap(P_Explanation* other);
  
  // implements Message ----------------------------------------------
  
  P_Explanation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Explanation& from);
  void MergeFrom(const P_Explanation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required .AIT.protocols.csp.aabt.P_CompoundAssignment lhs = 2;
  inline bool has_lhs() const;
  inline void clear_lhs();
  static const int kLhsFieldNumber = 2;
  inline const ::AIT::protocols::csp::aabt::P_CompoundAssignment& lhs() const;
  inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* mutable_lhs();
  inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* release_lhs();
  
  // required int32 rhs = 3;
  inline bool has_rhs() const;
  inline void clear_rhs();
  static const int kRhsFieldNumber = 3;
  inline ::google::protobuf::int32 rhs() const;
  inline void set_rhs(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_Explanation)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lhs();
  inline void clear_has_lhs();
  inline void set_has_rhs();
  inline void clear_has_rhs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::AIT::protocols::csp::aabt::P_CompoundAssignment* lhs_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 rhs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_Explanation* default_instance_;
};
// -------------------------------------------------------------------

class P_CVOrderData : public ::google::protobuf::Message {
 public:
  P_CVOrderData();
  virtual ~P_CVOrderData();
  
  P_CVOrderData(const P_CVOrderData& from);
  
  inline P_CVOrderData& operator=(const P_CVOrderData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_CVOrderData& default_instance();
  
  void Swap(P_CVOrderData* other);
  
  // implements Message ----------------------------------------------
  
  P_CVOrderData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_CVOrderData& from);
  void MergeFrom(const P_CVOrderData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .AIT.protocols.csp.aabt.P_Assignment assignment = 1;
  inline bool has_assignment() const;
  inline void clear_assignment();
  static const int kAssignmentFieldNumber = 1;
  inline const ::AIT::protocols::csp::aabt::P_Assignment& assignment() const;
  inline ::AIT::protocols::csp::aabt::P_Assignment* mutable_assignment();
  inline ::AIT::protocols::csp::aabt::P_Assignment* release_assignment();
  
  // repeated int32 order = 2;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::int32 order(int index) const;
  inline void set_order(int index, ::google::protobuf::int32 value);
  inline void add_order(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      order() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_order();
  
  // repeated int32 tv = 3;
  inline int tv_size() const;
  inline void clear_tv();
  static const int kTvFieldNumber = 3;
  inline ::google::protobuf::int32 tv(int index) const;
  inline void set_tv(int index, ::google::protobuf::int32 value);
  inline void add_tv(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tv() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tv();
  
  // repeated .AIT.protocols.csp.aabt.P_Explanation e = 4;
  inline int e_size() const;
  inline void clear_e();
  static const int kEFieldNumber = 4;
  inline const ::AIT::protocols::csp::aabt::P_Explanation& e(int index) const;
  inline ::AIT::protocols::csp::aabt::P_Explanation* mutable_e(int index);
  inline ::AIT::protocols::csp::aabt::P_Explanation* add_e();
  inline const ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Explanation >&
      e() const;
  inline ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Explanation >*
      mutable_e();
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_CVOrderData)
 private:
  inline void set_has_assignment();
  inline void clear_has_assignment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::AIT::protocols::csp::aabt::P_Assignment* assignment_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > order_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tv_;
  ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Explanation > e_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_CVOrderData* default_instance_;
};
// -------------------------------------------------------------------

class P_Message : public ::google::protobuf::Message {
 public:
  P_Message();
  virtual ~P_Message();
  
  P_Message(const P_Message& from);
  
  inline P_Message& operator=(const P_Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Message& default_instance();
  
  void Swap(P_Message* other);
  
  // implements Message ----------------------------------------------
  
  P_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Message& from);
  void MergeFrom(const P_Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .AIT.protocols.csp.aabt.P_MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline AIT::protocols::csp::aabt::P_MessageType type() const;
  inline void set_type(AIT::protocols::csp::aabt::P_MessageType value);
  
  // required int32 sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline ::google::protobuf::int32 sender() const;
  inline void set_sender(::google::protobuf::int32 value);
  
  // optional .AIT.protocols.csp.aabt.P_Assignment vi = 3;
  inline bool has_vi() const;
  inline void clear_vi();
  static const int kViFieldNumber = 3;
  inline const ::AIT::protocols::csp::aabt::P_Assignment& vi() const;
  inline ::AIT::protocols::csp::aabt::P_Assignment* mutable_vi();
  inline ::AIT::protocols::csp::aabt::P_Assignment* release_vi();
  
  // optional .AIT.protocols.csp.aabt.P_Explanation ei = 4;
  inline bool has_ei() const;
  inline void clear_ei();
  static const int kEiFieldNumber = 4;
  inline const ::AIT::protocols::csp::aabt::P_Explanation& ei() const;
  inline ::AIT::protocols::csp::aabt::P_Explanation* mutable_ei();
  inline ::AIT::protocols::csp::aabt::P_Explanation* release_ei();
  
  // repeated int32 oi = 5;
  inline int oi_size() const;
  inline void clear_oi();
  static const int kOiFieldNumber = 5;
  inline ::google::protobuf::int32 oi(int index) const;
  inline void set_oi(int index, ::google::protobuf::int32 value);
  inline void add_oi(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      oi() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_oi();
  
  // repeated int32 tvi = 6;
  inline int tvi_size() const;
  inline void clear_tvi();
  static const int kTviFieldNumber = 6;
  inline ::google::protobuf::int32 tvi(int index) const;
  inline void set_tvi(int index, ::google::protobuf::int32 value);
  inline void add_tvi(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tvi() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tvi();
  
  // optional .AIT.protocols.csp.aabt.P_NoGood nogood = 7;
  inline bool has_nogood() const;
  inline void clear_nogood();
  static const int kNogoodFieldNumber = 7;
  inline const ::AIT::protocols::csp::aabt::P_NoGood& nogood() const;
  inline ::AIT::protocols::csp::aabt::P_NoGood* mutable_nogood();
  inline ::AIT::protocols::csp::aabt::P_NoGood* release_nogood();
  
  // @@protoc_insertion_point(class_scope:AIT.protocols.csp.aabt.P_Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_vi();
  inline void clear_has_vi();
  inline void set_has_ei();
  inline void clear_has_ei();
  inline void set_has_nogood();
  inline void clear_has_nogood();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 sender_;
  ::AIT::protocols::csp::aabt::P_Assignment* vi_;
  ::AIT::protocols::csp::aabt::P_Explanation* ei_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > oi_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tvi_;
  ::AIT::protocols::csp::aabt::P_NoGood* nogood_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_AssignDesc_aabt_5fprecompiled_2eproto();
  friend void protobuf_ShutdownFile_aabt_5fprecompiled_2eproto();
  
  void InitAsDefaultInstance();
  static P_Message* default_instance_;
};
// ===================================================================


// ===================================================================

// P_Assignment

// required int32 id = 1;
inline bool P_Assignment::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Assignment::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Assignment::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Assignment::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_Assignment::id() const {
  return id_;
}
inline void P_Assignment::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 value = 2;
inline bool P_Assignment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_Assignment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_Assignment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_Assignment::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 P_Assignment::value() const {
  return value_;
}
inline void P_Assignment::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// required int32 time_stamp = 3;
inline bool P_Assignment::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_Assignment::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_Assignment::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_Assignment::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline ::google::protobuf::int32 P_Assignment::time_stamp() const {
  return time_stamp_;
}
inline void P_Assignment::set_time_stamp(::google::protobuf::int32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// -------------------------------------------------------------------

// P_CompoundAssignment

// repeated .AIT.protocols.csp.aabt.P_Assignment assignments = 1;
inline int P_CompoundAssignment::assignments_size() const {
  return assignments_.size();
}
inline void P_CompoundAssignment::clear_assignments() {
  assignments_.Clear();
}
inline const ::AIT::protocols::csp::aabt::P_Assignment& P_CompoundAssignment::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_CompoundAssignment::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_CompoundAssignment::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Assignment >&
P_CompoundAssignment::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Assignment >*
P_CompoundAssignment::mutable_assignments() {
  return &assignments_;
}

// -------------------------------------------------------------------

// P_NoGood

// required .AIT.protocols.csp.aabt.P_CompoundAssignment lhs = 1;
inline bool P_NoGood::has_lhs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_NoGood::set_has_lhs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_NoGood::clear_has_lhs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_NoGood::clear_lhs() {
  if (lhs_ != NULL) lhs_->::AIT::protocols::csp::aabt::P_CompoundAssignment::Clear();
  clear_has_lhs();
}
inline const ::AIT::protocols::csp::aabt::P_CompoundAssignment& P_NoGood::lhs() const {
  return lhs_ != NULL ? *lhs_ : *default_instance_->lhs_;
}
inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* P_NoGood::mutable_lhs() {
  set_has_lhs();
  if (lhs_ == NULL) lhs_ = new ::AIT::protocols::csp::aabt::P_CompoundAssignment;
  return lhs_;
}
inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* P_NoGood::release_lhs() {
  clear_has_lhs();
  ::AIT::protocols::csp::aabt::P_CompoundAssignment* temp = lhs_;
  lhs_ = NULL;
  return temp;
}

// required .AIT.protocols.csp.aabt.P_Assignment rhs = 2;
inline bool P_NoGood::has_rhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_NoGood::set_has_rhs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_NoGood::clear_has_rhs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_NoGood::clear_rhs() {
  if (rhs_ != NULL) rhs_->::AIT::protocols::csp::aabt::P_Assignment::Clear();
  clear_has_rhs();
}
inline const ::AIT::protocols::csp::aabt::P_Assignment& P_NoGood::rhs() const {
  return rhs_ != NULL ? *rhs_ : *default_instance_->rhs_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_NoGood::mutable_rhs() {
  set_has_rhs();
  if (rhs_ == NULL) rhs_ = new ::AIT::protocols::csp::aabt::P_Assignment;
  return rhs_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_NoGood::release_rhs() {
  clear_has_rhs();
  ::AIT::protocols::csp::aabt::P_Assignment* temp = rhs_;
  rhs_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// P_Explanation

// required int32 id = 1;
inline bool P_Explanation::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Explanation::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Explanation::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Explanation::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_Explanation::id() const {
  return id_;
}
inline void P_Explanation::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .AIT.protocols.csp.aabt.P_CompoundAssignment lhs = 2;
inline bool P_Explanation::has_lhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_Explanation::set_has_lhs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_Explanation::clear_has_lhs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_Explanation::clear_lhs() {
  if (lhs_ != NULL) lhs_->::AIT::protocols::csp::aabt::P_CompoundAssignment::Clear();
  clear_has_lhs();
}
inline const ::AIT::protocols::csp::aabt::P_CompoundAssignment& P_Explanation::lhs() const {
  return lhs_ != NULL ? *lhs_ : *default_instance_->lhs_;
}
inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* P_Explanation::mutable_lhs() {
  set_has_lhs();
  if (lhs_ == NULL) lhs_ = new ::AIT::protocols::csp::aabt::P_CompoundAssignment;
  return lhs_;
}
inline ::AIT::protocols::csp::aabt::P_CompoundAssignment* P_Explanation::release_lhs() {
  clear_has_lhs();
  ::AIT::protocols::csp::aabt::P_CompoundAssignment* temp = lhs_;
  lhs_ = NULL;
  return temp;
}

// required int32 rhs = 3;
inline bool P_Explanation::has_rhs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_Explanation::set_has_rhs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_Explanation::clear_has_rhs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_Explanation::clear_rhs() {
  rhs_ = 0;
  clear_has_rhs();
}
inline ::google::protobuf::int32 P_Explanation::rhs() const {
  return rhs_;
}
inline void P_Explanation::set_rhs(::google::protobuf::int32 value) {
  set_has_rhs();
  rhs_ = value;
}

// -------------------------------------------------------------------

// P_CVOrderData

// required .AIT.protocols.csp.aabt.P_Assignment assignment = 1;
inline bool P_CVOrderData::has_assignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_CVOrderData::set_has_assignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_CVOrderData::clear_has_assignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_CVOrderData::clear_assignment() {
  if (assignment_ != NULL) assignment_->::AIT::protocols::csp::aabt::P_Assignment::Clear();
  clear_has_assignment();
}
inline const ::AIT::protocols::csp::aabt::P_Assignment& P_CVOrderData::assignment() const {
  return assignment_ != NULL ? *assignment_ : *default_instance_->assignment_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_CVOrderData::mutable_assignment() {
  set_has_assignment();
  if (assignment_ == NULL) assignment_ = new ::AIT::protocols::csp::aabt::P_Assignment;
  return assignment_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_CVOrderData::release_assignment() {
  clear_has_assignment();
  ::AIT::protocols::csp::aabt::P_Assignment* temp = assignment_;
  assignment_ = NULL;
  return temp;
}

// repeated int32 order = 2;
inline int P_CVOrderData::order_size() const {
  return order_.size();
}
inline void P_CVOrderData::clear_order() {
  order_.Clear();
}
inline ::google::protobuf::int32 P_CVOrderData::order(int index) const {
  return order_.Get(index);
}
inline void P_CVOrderData::set_order(int index, ::google::protobuf::int32 value) {
  order_.Set(index, value);
}
inline void P_CVOrderData::add_order(::google::protobuf::int32 value) {
  order_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
P_CVOrderData::order() const {
  return order_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
P_CVOrderData::mutable_order() {
  return &order_;
}

// repeated int32 tv = 3;
inline int P_CVOrderData::tv_size() const {
  return tv_.size();
}
inline void P_CVOrderData::clear_tv() {
  tv_.Clear();
}
inline ::google::protobuf::int32 P_CVOrderData::tv(int index) const {
  return tv_.Get(index);
}
inline void P_CVOrderData::set_tv(int index, ::google::protobuf::int32 value) {
  tv_.Set(index, value);
}
inline void P_CVOrderData::add_tv(::google::protobuf::int32 value) {
  tv_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
P_CVOrderData::tv() const {
  return tv_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
P_CVOrderData::mutable_tv() {
  return &tv_;
}

// repeated .AIT.protocols.csp.aabt.P_Explanation e = 4;
inline int P_CVOrderData::e_size() const {
  return e_.size();
}
inline void P_CVOrderData::clear_e() {
  e_.Clear();
}
inline const ::AIT::protocols::csp::aabt::P_Explanation& P_CVOrderData::e(int index) const {
  return e_.Get(index);
}
inline ::AIT::protocols::csp::aabt::P_Explanation* P_CVOrderData::mutable_e(int index) {
  return e_.Mutable(index);
}
inline ::AIT::protocols::csp::aabt::P_Explanation* P_CVOrderData::add_e() {
  return e_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Explanation >&
P_CVOrderData::e() const {
  return e_;
}
inline ::google::protobuf::RepeatedPtrField< ::AIT::protocols::csp::aabt::P_Explanation >*
P_CVOrderData::mutable_e() {
  return &e_;
}

// -------------------------------------------------------------------

// P_Message

// required .AIT.protocols.csp.aabt.P_MessageType type = 1;
inline bool P_Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline AIT::protocols::csp::aabt::P_MessageType P_Message::type() const {
  return static_cast< AIT::protocols::csp::aabt::P_MessageType >(type_);
}
inline void P_Message::set_type(AIT::protocols::csp::aabt::P_MessageType value) {
  GOOGLE_DCHECK(AIT::protocols::csp::aabt::P_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 sender = 2;
inline bool P_Message::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_Message::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_Message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_Message::clear_sender() {
  sender_ = 0;
  clear_has_sender();
}
inline ::google::protobuf::int32 P_Message::sender() const {
  return sender_;
}
inline void P_Message::set_sender(::google::protobuf::int32 value) {
  set_has_sender();
  sender_ = value;
}

// optional .AIT.protocols.csp.aabt.P_Assignment vi = 3;
inline bool P_Message::has_vi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_Message::set_has_vi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_Message::clear_has_vi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_Message::clear_vi() {
  if (vi_ != NULL) vi_->::AIT::protocols::csp::aabt::P_Assignment::Clear();
  clear_has_vi();
}
inline const ::AIT::protocols::csp::aabt::P_Assignment& P_Message::vi() const {
  return vi_ != NULL ? *vi_ : *default_instance_->vi_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_Message::mutable_vi() {
  set_has_vi();
  if (vi_ == NULL) vi_ = new ::AIT::protocols::csp::aabt::P_Assignment;
  return vi_;
}
inline ::AIT::protocols::csp::aabt::P_Assignment* P_Message::release_vi() {
  clear_has_vi();
  ::AIT::protocols::csp::aabt::P_Assignment* temp = vi_;
  vi_ = NULL;
  return temp;
}

// optional .AIT.protocols.csp.aabt.P_Explanation ei = 4;
inline bool P_Message::has_ei() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void P_Message::set_has_ei() {
  _has_bits_[0] |= 0x00000008u;
}
inline void P_Message::clear_has_ei() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void P_Message::clear_ei() {
  if (ei_ != NULL) ei_->::AIT::protocols::csp::aabt::P_Explanation::Clear();
  clear_has_ei();
}
inline const ::AIT::protocols::csp::aabt::P_Explanation& P_Message::ei() const {
  return ei_ != NULL ? *ei_ : *default_instance_->ei_;
}
inline ::AIT::protocols::csp::aabt::P_Explanation* P_Message::mutable_ei() {
  set_has_ei();
  if (ei_ == NULL) ei_ = new ::AIT::protocols::csp::aabt::P_Explanation;
  return ei_;
}
inline ::AIT::protocols::csp::aabt::P_Explanation* P_Message::release_ei() {
  clear_has_ei();
  ::AIT::protocols::csp::aabt::P_Explanation* temp = ei_;
  ei_ = NULL;
  return temp;
}

// repeated int32 oi = 5;
inline int P_Message::oi_size() const {
  return oi_.size();
}
inline void P_Message::clear_oi() {
  oi_.Clear();
}
inline ::google::protobuf::int32 P_Message::oi(int index) const {
  return oi_.Get(index);
}
inline void P_Message::set_oi(int index, ::google::protobuf::int32 value) {
  oi_.Set(index, value);
}
inline void P_Message::add_oi(::google::protobuf::int32 value) {
  oi_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
P_Message::oi() const {
  return oi_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
P_Message::mutable_oi() {
  return &oi_;
}

// repeated int32 tvi = 6;
inline int P_Message::tvi_size() const {
  return tvi_.size();
}
inline void P_Message::clear_tvi() {
  tvi_.Clear();
}
inline ::google::protobuf::int32 P_Message::tvi(int index) const {
  return tvi_.Get(index);
}
inline void P_Message::set_tvi(int index, ::google::protobuf::int32 value) {
  tvi_.Set(index, value);
}
inline void P_Message::add_tvi(::google::protobuf::int32 value) {
  tvi_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
P_Message::tvi() const {
  return tvi_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
P_Message::mutable_tvi() {
  return &tvi_;
}

// optional .AIT.protocols.csp.aabt.P_NoGood nogood = 7;
inline bool P_Message::has_nogood() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void P_Message::set_has_nogood() {
  _has_bits_[0] |= 0x00000040u;
}
inline void P_Message::clear_has_nogood() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void P_Message::clear_nogood() {
  if (nogood_ != NULL) nogood_->::AIT::protocols::csp::aabt::P_NoGood::Clear();
  clear_has_nogood();
}
inline const ::AIT::protocols::csp::aabt::P_NoGood& P_Message::nogood() const {
  return nogood_ != NULL ? *nogood_ : *default_instance_->nogood_;
}
inline ::AIT::protocols::csp::aabt::P_NoGood* P_Message::mutable_nogood() {
  set_has_nogood();
  if (nogood_ == NULL) nogood_ = new ::AIT::protocols::csp::aabt::P_NoGood;
  return nogood_;
}
inline ::AIT::protocols::csp::aabt::P_NoGood* P_Message::release_nogood() {
  clear_has_nogood();
  ::AIT::protocols::csp::aabt::P_NoGood* temp = nogood_;
  nogood_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace aabt
}  // namespace csp
}  // namespace protocols
}  // namespace AIT

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< AIT::protocols::csp::aabt::P_MessageType>() {
  return AIT::protocols::csp::aabt::P_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_aabt_5fprecompiled_2eproto__INCLUDED
