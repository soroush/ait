// Generated by Bisonc++ V2.09.03 on Mon, 15 Jul 2013 16:59:25 +0430

#ifndef FunctionalParser_h_included
#define FunctionalParser_h_included

#include "predicate-f_parserbase.h"
#include "predicate-f_scanner.h"
#include "expression.h"
#include <sstream>
#include <vector>
#include <map>

#undef FunctionalParser
class FunctionalParser: public FunctionalParserBase {

public:
	FunctionalParser(const std::string& input,
			std::vector<AIT::CSP::Expression*>& postfix,
			const std::vector<int>& variables,
			const std::map<std::string, size_t>& names);
	int parse();

private:
	std::istringstream str;
	PredicateFunctionalLexer d_scanner;
	std::vector<AIT::CSP::Expression*>& postfix;
	const std::vector<int>& variables;
	const std::map<std::string, size_t>& names;

	void error(char const *msg);
	int lex();
	void print();
	void executeAction(int ruleNr);
	void errorRecovery();
	int lookup(bool recovery);
	void nextToken();
};

inline void FunctionalParser::error(char const *msg) {
	std::cerr << msg << '\n';
}

inline int FunctionalParser::lex() {
	return d_scanner.lex();
}

inline FunctionalParser::FunctionalParser(const std::string& input,
		std::vector<AIT::CSP::Expression*>& outputVector,
		const std::vector<int>& variables_,
		const std::map<std::string, size_t>& names_) :
		str(input), d_scanner(str, std::cout), postfix(outputVector), variables(
				variables_), names(names_) {
	postfix.clear();
	// TODO: Check if there is a memory leak or not.
}

inline void FunctionalParser::print() {
}

#endif
