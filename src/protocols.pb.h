// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocols.proto

#ifndef PROTOBUF_protocols_2eproto__INCLUDED
#define PROTOBUF_protocols_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocols {
namespace ABT {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocols_2eproto();
void protobuf_AssignDesc_protocols_2eproto();
void protobuf_ShutdownFile_protocols_2eproto();

class P_EndPoint;
class P_CommunicationProtocol;
class P_Assignment;
class P_CompoundAssignment;
class P_Message;
class P_Message_OK;
class P_Message_NOGOOD;

enum CP_MessageType {
  T_INTRODUCE = 1,
  T_INTRODUCE_ACK = 2,
  T_REQUEST_LIST = 3,
  T_REQUEST_ACK = 4,
  T_LIST = 5,
  ERR_NO_MORE_AGENTS = 6,
  ERR_REPEATED_ID = 7,
  ERR_UNKNOWN = 8
};
bool CP_MessageType_IsValid(int value);
const CP_MessageType CP_MessageType_MIN = T_INTRODUCE;
const CP_MessageType CP_MessageType_MAX = ERR_UNKNOWN;
const int CP_MessageType_ARRAYSIZE = CP_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CP_MessageType_descriptor();
inline const ::std::string& CP_MessageType_Name(CP_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CP_MessageType_descriptor(), value);
}
inline bool CP_MessageType_Parse(
    const ::std::string& name, CP_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CP_MessageType>(
    CP_MessageType_descriptor(), name, value);
}
enum ABT_MessageType {
  T_OK = 1,
  T_NOGOOD = 2,
  T_ADDLINK = 3,
  T_STOP = 4
};
bool ABT_MessageType_IsValid(int value);
const ABT_MessageType ABT_MessageType_MIN = T_OK;
const ABT_MessageType ABT_MessageType_MAX = T_STOP;
const int ABT_MessageType_ARRAYSIZE = ABT_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ABT_MessageType_descriptor();
inline const ::std::string& ABT_MessageType_Name(ABT_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ABT_MessageType_descriptor(), value);
}
inline bool ABT_MessageType_Parse(
    const ::std::string& name, ABT_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ABT_MessageType>(
    ABT_MessageType_descriptor(), name, value);
}
// ===================================================================

class P_EndPoint : public ::google::protobuf::Message {
 public:
  P_EndPoint();
  virtual ~P_EndPoint();

  P_EndPoint(const P_EndPoint& from);

  inline P_EndPoint& operator=(const P_EndPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_EndPoint& default_instance();

  void Swap(P_EndPoint* other);

  // implements Message ----------------------------------------------

  P_EndPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_EndPoint& from);
  void MergeFrom(const P_EndPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_EndPoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_EndPoint* default_instance_;
};
// -------------------------------------------------------------------

class P_CommunicationProtocol : public ::google::protobuf::Message {
 public:
  P_CommunicationProtocol();
  virtual ~P_CommunicationProtocol();

  P_CommunicationProtocol(const P_CommunicationProtocol& from);

  inline P_CommunicationProtocol& operator=(const P_CommunicationProtocol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_CommunicationProtocol& default_instance();

  void Swap(P_CommunicationProtocol* other);

  // implements Message ----------------------------------------------

  P_CommunicationProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_CommunicationProtocol& from);
  void MergeFrom(const P_CommunicationProtocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocols.ABT.CP_MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::protocols::ABT::CP_MessageType type() const;
  inline void set_type(::protocols::ABT::CP_MessageType value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .protocols.ABT.P_EndPoint identity = 3;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 3;
  inline const ::protocols::ABT::P_EndPoint& identity() const;
  inline ::protocols::ABT::P_EndPoint* mutable_identity();
  inline ::protocols::ABT::P_EndPoint* release_identity();
  inline void set_allocated_identity(::protocols::ABT::P_EndPoint* identity);

  // repeated .protocols.ABT.P_EndPoint others = 4;
  inline int others_size() const;
  inline void clear_others();
  static const int kOthersFieldNumber = 4;
  inline const ::protocols::ABT::P_EndPoint& others(int index) const;
  inline ::protocols::ABT::P_EndPoint* mutable_others(int index);
  inline ::protocols::ABT::P_EndPoint* add_others();
  inline const ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_EndPoint >&
      others() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_EndPoint >*
      mutable_others();

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_CommunicationProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::protocols::ABT::P_EndPoint* identity_;
  ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_EndPoint > others_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_CommunicationProtocol* default_instance_;
};
// -------------------------------------------------------------------

class P_Assignment : public ::google::protobuf::Message {
 public:
  P_Assignment();
  virtual ~P_Assignment();

  P_Assignment(const P_Assignment& from);

  inline P_Assignment& operator=(const P_Assignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Assignment& default_instance();

  void Swap(P_Assignment* other);

  // implements Message ----------------------------------------------

  P_Assignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Assignment& from);
  void MergeFrom(const P_Assignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_Assignment)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_Assignment* default_instance_;
};
// -------------------------------------------------------------------

class P_CompoundAssignment : public ::google::protobuf::Message {
 public:
  P_CompoundAssignment();
  virtual ~P_CompoundAssignment();

  P_CompoundAssignment(const P_CompoundAssignment& from);

  inline P_CompoundAssignment& operator=(const P_CompoundAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_CompoundAssignment& default_instance();

  void Swap(P_CompoundAssignment* other);

  // implements Message ----------------------------------------------

  P_CompoundAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_CompoundAssignment& from);
  void MergeFrom(const P_CompoundAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocols.ABT.P_Assignment assignments = 1;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 1;
  inline const ::protocols::ABT::P_Assignment& assignments(int index) const;
  inline ::protocols::ABT::P_Assignment* mutable_assignments(int index);
  inline ::protocols::ABT::P_Assignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_Assignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_Assignment >*
      mutable_assignments();

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_CompoundAssignment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_Assignment > assignments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_CompoundAssignment* default_instance_;
};
// -------------------------------------------------------------------

class P_Message_OK : public ::google::protobuf::Message {
 public:
  P_Message_OK();
  virtual ~P_Message_OK();

  P_Message_OK(const P_Message_OK& from);

  inline P_Message_OK& operator=(const P_Message_OK& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Message_OK& default_instance();

  void Swap(P_Message_OK* other);

  // implements Message ----------------------------------------------

  P_Message_OK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Message_OK& from);
  void MergeFrom(const P_Message_OK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocols.ABT.P_Assignment assignment = 1;
  inline bool has_assignment() const;
  inline void clear_assignment();
  static const int kAssignmentFieldNumber = 1;
  inline const ::protocols::ABT::P_Assignment& assignment() const;
  inline ::protocols::ABT::P_Assignment* mutable_assignment();
  inline ::protocols::ABT::P_Assignment* release_assignment();
  inline void set_allocated_assignment(::protocols::ABT::P_Assignment* assignment);

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_Message.OK)
 private:
  inline void set_has_assignment();
  inline void clear_has_assignment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocols::ABT::P_Assignment* assignment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_Message_OK* default_instance_;
};
// -------------------------------------------------------------------

class P_Message_NOGOOD : public ::google::protobuf::Message {
 public:
  P_Message_NOGOOD();
  virtual ~P_Message_NOGOOD();

  P_Message_NOGOOD(const P_Message_NOGOOD& from);

  inline P_Message_NOGOOD& operator=(const P_Message_NOGOOD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Message_NOGOOD& default_instance();

  void Swap(P_Message_NOGOOD* other);

  // implements Message ----------------------------------------------

  P_Message_NOGOOD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Message_NOGOOD& from);
  void MergeFrom(const P_Message_NOGOOD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocols.ABT.P_CompoundAssignment nogood = 1;
  inline bool has_nogood() const;
  inline void clear_nogood();
  static const int kNogoodFieldNumber = 1;
  inline const ::protocols::ABT::P_CompoundAssignment& nogood() const;
  inline ::protocols::ABT::P_CompoundAssignment* mutable_nogood();
  inline ::protocols::ABT::P_CompoundAssignment* release_nogood();
  inline void set_allocated_nogood(::protocols::ABT::P_CompoundAssignment* nogood);

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_Message.NOGOOD)
 private:
  inline void set_has_nogood();
  inline void clear_has_nogood();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocols::ABT::P_CompoundAssignment* nogood_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_Message_NOGOOD* default_instance_;
};
// -------------------------------------------------------------------

class P_Message : public ::google::protobuf::Message {
 public:
  P_Message();
  virtual ~P_Message();

  P_Message(const P_Message& from);

  inline P_Message& operator=(const P_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P_Message& default_instance();

  void Swap(P_Message* other);

  // implements Message ----------------------------------------------

  P_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P_Message& from);
  void MergeFrom(const P_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef P_Message_OK OK;
  typedef P_Message_NOGOOD NOGOOD;

  // accessors -------------------------------------------------------

  // required .protocols.ABT.ABT_MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::protocols::ABT::ABT_MessageType type() const;
  inline void set_type(::protocols::ABT::ABT_MessageType value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .protocols.ABT.P_Message.OK ok_data = 3;
  inline bool has_ok_data() const;
  inline void clear_ok_data();
  static const int kOkDataFieldNumber = 3;
  inline const ::protocols::ABT::P_Message_OK& ok_data() const;
  inline ::protocols::ABT::P_Message_OK* mutable_ok_data();
  inline ::protocols::ABT::P_Message_OK* release_ok_data();
  inline void set_allocated_ok_data(::protocols::ABT::P_Message_OK* ok_data);

  // optional .protocols.ABT.P_Message.NOGOOD nogood_data = 4;
  inline bool has_nogood_data() const;
  inline void clear_nogood_data();
  static const int kNogoodDataFieldNumber = 4;
  inline const ::protocols::ABT::P_Message_NOGOOD& nogood_data() const;
  inline ::protocols::ABT::P_Message_NOGOOD* mutable_nogood_data();
  inline ::protocols::ABT::P_Message_NOGOOD* release_nogood_data();
  inline void set_allocated_nogood_data(::protocols::ABT::P_Message_NOGOOD* nogood_data);

  // @@protoc_insertion_point(class_scope:protocols.ABT.P_Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ok_data();
  inline void clear_has_ok_data();
  inline void set_has_nogood_data();
  inline void clear_has_nogood_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::protocols::ABT::P_Message_OK* ok_data_;
  ::protocols::ABT::P_Message_NOGOOD* nogood_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static P_Message* default_instance_;
};
// ===================================================================


// ===================================================================

// P_EndPoint

// required int32 id = 1;
inline bool P_EndPoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_EndPoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_EndPoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_EndPoint::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_EndPoint::id() const {
  return id_;
}
inline void P_EndPoint::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string host = 2;
inline bool P_EndPoint::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_EndPoint::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_EndPoint::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_EndPoint::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& P_EndPoint::host() const {
  return *host_;
}
inline void P_EndPoint::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void P_EndPoint::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void P_EndPoint::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* P_EndPoint::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* P_EndPoint::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void P_EndPoint::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 3;
inline bool P_EndPoint::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_EndPoint::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_EndPoint::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_EndPoint::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 P_EndPoint::port() const {
  return port_;
}
inline void P_EndPoint::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// P_CommunicationProtocol

// required .protocols.ABT.CP_MessageType type = 1;
inline bool P_CommunicationProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_CommunicationProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_CommunicationProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_CommunicationProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protocols::ABT::CP_MessageType P_CommunicationProtocol::type() const {
  return static_cast< ::protocols::ABT::CP_MessageType >(type_);
}
inline void P_CommunicationProtocol::set_type(::protocols::ABT::CP_MessageType value) {
  assert(::protocols::ABT::CP_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool P_CommunicationProtocol::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_CommunicationProtocol::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_CommunicationProtocol::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_CommunicationProtocol::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_CommunicationProtocol::id() const {
  return id_;
}
inline void P_CommunicationProtocol::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .protocols.ABT.P_EndPoint identity = 3;
inline bool P_CommunicationProtocol::has_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_CommunicationProtocol::set_has_identity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_CommunicationProtocol::clear_has_identity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_CommunicationProtocol::clear_identity() {
  if (identity_ != NULL) identity_->::protocols::ABT::P_EndPoint::Clear();
  clear_has_identity();
}
inline const ::protocols::ABT::P_EndPoint& P_CommunicationProtocol::identity() const {
  return identity_ != NULL ? *identity_ : *default_instance_->identity_;
}
inline ::protocols::ABT::P_EndPoint* P_CommunicationProtocol::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) identity_ = new ::protocols::ABT::P_EndPoint;
  return identity_;
}
inline ::protocols::ABT::P_EndPoint* P_CommunicationProtocol::release_identity() {
  clear_has_identity();
  ::protocols::ABT::P_EndPoint* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void P_CommunicationProtocol::set_allocated_identity(::protocols::ABT::P_EndPoint* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
}

// repeated .protocols.ABT.P_EndPoint others = 4;
inline int P_CommunicationProtocol::others_size() const {
  return others_.size();
}
inline void P_CommunicationProtocol::clear_others() {
  others_.Clear();
}
inline const ::protocols::ABT::P_EndPoint& P_CommunicationProtocol::others(int index) const {
  return others_.Get(index);
}
inline ::protocols::ABT::P_EndPoint* P_CommunicationProtocol::mutable_others(int index) {
  return others_.Mutable(index);
}
inline ::protocols::ABT::P_EndPoint* P_CommunicationProtocol::add_others() {
  return others_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_EndPoint >&
P_CommunicationProtocol::others() const {
  return others_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_EndPoint >*
P_CommunicationProtocol::mutable_others() {
  return &others_;
}

// -------------------------------------------------------------------

// P_Assignment

// required int32 id = 1;
inline bool P_Assignment::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Assignment::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Assignment::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Assignment::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_Assignment::id() const {
  return id_;
}
inline void P_Assignment::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 value = 2;
inline bool P_Assignment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_Assignment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_Assignment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_Assignment::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 P_Assignment::value() const {
  return value_;
}
inline void P_Assignment::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// P_CompoundAssignment

// repeated .protocols.ABT.P_Assignment assignments = 1;
inline int P_CompoundAssignment::assignments_size() const {
  return assignments_.size();
}
inline void P_CompoundAssignment::clear_assignments() {
  assignments_.Clear();
}
inline const ::protocols::ABT::P_Assignment& P_CompoundAssignment::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::protocols::ABT::P_Assignment* P_CompoundAssignment::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::protocols::ABT::P_Assignment* P_CompoundAssignment::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_Assignment >&
P_CompoundAssignment::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocols::ABT::P_Assignment >*
P_CompoundAssignment::mutable_assignments() {
  return &assignments_;
}

// -------------------------------------------------------------------

// P_Message_OK

// required .protocols.ABT.P_Assignment assignment = 1;
inline bool P_Message_OK::has_assignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Message_OK::set_has_assignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Message_OK::clear_has_assignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Message_OK::clear_assignment() {
  if (assignment_ != NULL) assignment_->::protocols::ABT::P_Assignment::Clear();
  clear_has_assignment();
}
inline const ::protocols::ABT::P_Assignment& P_Message_OK::assignment() const {
  return assignment_ != NULL ? *assignment_ : *default_instance_->assignment_;
}
inline ::protocols::ABT::P_Assignment* P_Message_OK::mutable_assignment() {
  set_has_assignment();
  if (assignment_ == NULL) assignment_ = new ::protocols::ABT::P_Assignment;
  return assignment_;
}
inline ::protocols::ABT::P_Assignment* P_Message_OK::release_assignment() {
  clear_has_assignment();
  ::protocols::ABT::P_Assignment* temp = assignment_;
  assignment_ = NULL;
  return temp;
}
inline void P_Message_OK::set_allocated_assignment(::protocols::ABT::P_Assignment* assignment) {
  delete assignment_;
  assignment_ = assignment;
  if (assignment) {
    set_has_assignment();
  } else {
    clear_has_assignment();
  }
}

// -------------------------------------------------------------------

// P_Message_NOGOOD

// required .protocols.ABT.P_CompoundAssignment nogood = 1;
inline bool P_Message_NOGOOD::has_nogood() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Message_NOGOOD::set_has_nogood() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Message_NOGOOD::clear_has_nogood() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Message_NOGOOD::clear_nogood() {
  if (nogood_ != NULL) nogood_->::protocols::ABT::P_CompoundAssignment::Clear();
  clear_has_nogood();
}
inline const ::protocols::ABT::P_CompoundAssignment& P_Message_NOGOOD::nogood() const {
  return nogood_ != NULL ? *nogood_ : *default_instance_->nogood_;
}
inline ::protocols::ABT::P_CompoundAssignment* P_Message_NOGOOD::mutable_nogood() {
  set_has_nogood();
  if (nogood_ == NULL) nogood_ = new ::protocols::ABT::P_CompoundAssignment;
  return nogood_;
}
inline ::protocols::ABT::P_CompoundAssignment* P_Message_NOGOOD::release_nogood() {
  clear_has_nogood();
  ::protocols::ABT::P_CompoundAssignment* temp = nogood_;
  nogood_ = NULL;
  return temp;
}
inline void P_Message_NOGOOD::set_allocated_nogood(::protocols::ABT::P_CompoundAssignment* nogood) {
  delete nogood_;
  nogood_ = nogood;
  if (nogood) {
    set_has_nogood();
  } else {
    clear_has_nogood();
  }
}

// -------------------------------------------------------------------

// P_Message

// required .protocols.ABT.ABT_MessageType type = 1;
inline bool P_Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P_Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P_Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P_Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protocols::ABT::ABT_MessageType P_Message::type() const {
  return static_cast< ::protocols::ABT::ABT_MessageType >(type_);
}
inline void P_Message::set_type(::protocols::ABT::ABT_MessageType value) {
  assert(::protocols::ABT::ABT_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 id = 2;
inline bool P_Message::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P_Message::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P_Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P_Message::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 P_Message::id() const {
  return id_;
}
inline void P_Message::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .protocols.ABT.P_Message.OK ok_data = 3;
inline bool P_Message::has_ok_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P_Message::set_has_ok_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P_Message::clear_has_ok_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P_Message::clear_ok_data() {
  if (ok_data_ != NULL) ok_data_->::protocols::ABT::P_Message_OK::Clear();
  clear_has_ok_data();
}
inline const ::protocols::ABT::P_Message_OK& P_Message::ok_data() const {
  return ok_data_ != NULL ? *ok_data_ : *default_instance_->ok_data_;
}
inline ::protocols::ABT::P_Message_OK* P_Message::mutable_ok_data() {
  set_has_ok_data();
  if (ok_data_ == NULL) ok_data_ = new ::protocols::ABT::P_Message_OK;
  return ok_data_;
}
inline ::protocols::ABT::P_Message_OK* P_Message::release_ok_data() {
  clear_has_ok_data();
  ::protocols::ABT::P_Message_OK* temp = ok_data_;
  ok_data_ = NULL;
  return temp;
}
inline void P_Message::set_allocated_ok_data(::protocols::ABT::P_Message_OK* ok_data) {
  delete ok_data_;
  ok_data_ = ok_data;
  if (ok_data) {
    set_has_ok_data();
  } else {
    clear_has_ok_data();
  }
}

// optional .protocols.ABT.P_Message.NOGOOD nogood_data = 4;
inline bool P_Message::has_nogood_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void P_Message::set_has_nogood_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void P_Message::clear_has_nogood_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void P_Message::clear_nogood_data() {
  if (nogood_data_ != NULL) nogood_data_->::protocols::ABT::P_Message_NOGOOD::Clear();
  clear_has_nogood_data();
}
inline const ::protocols::ABT::P_Message_NOGOOD& P_Message::nogood_data() const {
  return nogood_data_ != NULL ? *nogood_data_ : *default_instance_->nogood_data_;
}
inline ::protocols::ABT::P_Message_NOGOOD* P_Message::mutable_nogood_data() {
  set_has_nogood_data();
  if (nogood_data_ == NULL) nogood_data_ = new ::protocols::ABT::P_Message_NOGOOD;
  return nogood_data_;
}
inline ::protocols::ABT::P_Message_NOGOOD* P_Message::release_nogood_data() {
  clear_has_nogood_data();
  ::protocols::ABT::P_Message_NOGOOD* temp = nogood_data_;
  nogood_data_ = NULL;
  return temp;
}
inline void P_Message::set_allocated_nogood_data(::protocols::ABT::P_Message_NOGOOD* nogood_data) {
  delete nogood_data_;
  nogood_data_ = nogood_data;
  if (nogood_data) {
    set_has_nogood_data();
  } else {
    clear_has_nogood_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ABT
}  // namespace protocols

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocols::ABT::CP_MessageType>() {
  return ::protocols::ABT::CP_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocols::ABT::ABT_MessageType>() {
  return ::protocols::ABT::ABT_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocols_2eproto__INCLUDED
