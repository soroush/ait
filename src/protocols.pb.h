// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocols.proto

#ifndef PROTOBUF_protocols_2eproto__INCLUDED
#define PROTOBUF_protocols_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocols_2eproto();
void protobuf_AssignDesc_protocols_2eproto();
void protobuf_ShutdownFile_protocols_2eproto();

class ABT_CommunicationProtocol;
class ABT_CommunicationProtocol_AgentIdentity;
class ABT_Assignment;
class ABT_CompoundAssignment;
class ABT_Message;
class ABT_Message_OK;
class ABT_Message_NOGOOD;

enum ABT_CommunicationProtocol_MessageType {
  ABT_CommunicationProtocol_MessageType_T_INTRODUCE = 1,
  ABT_CommunicationProtocol_MessageType_T_GET_LIST = 2,
  ABT_CommunicationProtocol_MessageType_T_BYE = 3,
  ABT_CommunicationProtocol_MessageType_T_ACK = 4
};
bool ABT_CommunicationProtocol_MessageType_IsValid(int value);
const ABT_CommunicationProtocol_MessageType ABT_CommunicationProtocol_MessageType_MessageType_MIN = ABT_CommunicationProtocol_MessageType_T_INTRODUCE;
const ABT_CommunicationProtocol_MessageType ABT_CommunicationProtocol_MessageType_MessageType_MAX = ABT_CommunicationProtocol_MessageType_T_ACK;
const int ABT_CommunicationProtocol_MessageType_MessageType_ARRAYSIZE = ABT_CommunicationProtocol_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ABT_CommunicationProtocol_MessageType_descriptor();
inline const ::std::string& ABT_CommunicationProtocol_MessageType_Name(ABT_CommunicationProtocol_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ABT_CommunicationProtocol_MessageType_descriptor(), value);
}
inline bool ABT_CommunicationProtocol_MessageType_Parse(
    const ::std::string& name, ABT_CommunicationProtocol_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ABT_CommunicationProtocol_MessageType>(
    ABT_CommunicationProtocol_MessageType_descriptor(), name, value);
}
enum ABT_Message_MessageType {
  ABT_Message_MessageType_T_OK = 1,
  ABT_Message_MessageType_T_NOGOOD = 2,
  ABT_Message_MessageType_T_ADDLINK = 3,
  ABT_Message_MessageType_T_STOP = 4
};
bool ABT_Message_MessageType_IsValid(int value);
const ABT_Message_MessageType ABT_Message_MessageType_MessageType_MIN = ABT_Message_MessageType_T_OK;
const ABT_Message_MessageType ABT_Message_MessageType_MessageType_MAX = ABT_Message_MessageType_T_STOP;
const int ABT_Message_MessageType_MessageType_ARRAYSIZE = ABT_Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ABT_Message_MessageType_descriptor();
inline const ::std::string& ABT_Message_MessageType_Name(ABT_Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ABT_Message_MessageType_descriptor(), value);
}
inline bool ABT_Message_MessageType_Parse(
    const ::std::string& name, ABT_Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ABT_Message_MessageType>(
    ABT_Message_MessageType_descriptor(), name, value);
}
// ===================================================================

class ABT_CommunicationProtocol_AgentIdentity : public ::google::protobuf::Message {
 public:
  ABT_CommunicationProtocol_AgentIdentity();
  virtual ~ABT_CommunicationProtocol_AgentIdentity();

  ABT_CommunicationProtocol_AgentIdentity(const ABT_CommunicationProtocol_AgentIdentity& from);

  inline ABT_CommunicationProtocol_AgentIdentity& operator=(const ABT_CommunicationProtocol_AgentIdentity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_CommunicationProtocol_AgentIdentity& default_instance();

  void Swap(ABT_CommunicationProtocol_AgentIdentity* other);

  // implements Message ----------------------------------------------

  ABT_CommunicationProtocol_AgentIdentity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_CommunicationProtocol_AgentIdentity& from);
  void MergeFrom(const ABT_CommunicationProtocol_AgentIdentity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ABT_CommunicationProtocol.AgentIdentity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_CommunicationProtocol_AgentIdentity* default_instance_;
};
// -------------------------------------------------------------------

class ABT_CommunicationProtocol : public ::google::protobuf::Message {
 public:
  ABT_CommunicationProtocol();
  virtual ~ABT_CommunicationProtocol();

  ABT_CommunicationProtocol(const ABT_CommunicationProtocol& from);

  inline ABT_CommunicationProtocol& operator=(const ABT_CommunicationProtocol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_CommunicationProtocol& default_instance();

  void Swap(ABT_CommunicationProtocol* other);

  // implements Message ----------------------------------------------

  ABT_CommunicationProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_CommunicationProtocol& from);
  void MergeFrom(const ABT_CommunicationProtocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ABT_CommunicationProtocol_AgentIdentity AgentIdentity;

  typedef ABT_CommunicationProtocol_MessageType MessageType;
  static const MessageType T_INTRODUCE = ABT_CommunicationProtocol_MessageType_T_INTRODUCE;
  static const MessageType T_GET_LIST = ABT_CommunicationProtocol_MessageType_T_GET_LIST;
  static const MessageType T_BYE = ABT_CommunicationProtocol_MessageType_T_BYE;
  static const MessageType T_ACK = ABT_CommunicationProtocol_MessageType_T_ACK;
  static inline bool MessageType_IsValid(int value) {
    return ABT_CommunicationProtocol_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    ABT_CommunicationProtocol_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    ABT_CommunicationProtocol_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    ABT_CommunicationProtocol_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return ABT_CommunicationProtocol_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return ABT_CommunicationProtocol_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return ABT_CommunicationProtocol_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ABT_CommunicationProtocol.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ABT_CommunicationProtocol_MessageType type() const;
  inline void set_type(::ABT_CommunicationProtocol_MessageType value);

  // optional .ABT_CommunicationProtocol.AgentIdentity identity = 2;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 2;
  inline const ::ABT_CommunicationProtocol_AgentIdentity& identity() const;
  inline ::ABT_CommunicationProtocol_AgentIdentity* mutable_identity();
  inline ::ABT_CommunicationProtocol_AgentIdentity* release_identity();
  inline void set_allocated_identity(::ABT_CommunicationProtocol_AgentIdentity* identity);

  // repeated .ABT_CommunicationProtocol.AgentIdentity others = 3;
  inline int others_size() const;
  inline void clear_others();
  static const int kOthersFieldNumber = 3;
  inline const ::ABT_CommunicationProtocol_AgentIdentity& others(int index) const;
  inline ::ABT_CommunicationProtocol_AgentIdentity* mutable_others(int index);
  inline ::ABT_CommunicationProtocol_AgentIdentity* add_others();
  inline const ::google::protobuf::RepeatedPtrField< ::ABT_CommunicationProtocol_AgentIdentity >&
      others() const;
  inline ::google::protobuf::RepeatedPtrField< ::ABT_CommunicationProtocol_AgentIdentity >*
      mutable_others();

  // @@protoc_insertion_point(class_scope:ABT_CommunicationProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ABT_CommunicationProtocol_AgentIdentity* identity_;
  ::google::protobuf::RepeatedPtrField< ::ABT_CommunicationProtocol_AgentIdentity > others_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_CommunicationProtocol* default_instance_;
};
// -------------------------------------------------------------------

class ABT_Assignment : public ::google::protobuf::Message {
 public:
  ABT_Assignment();
  virtual ~ABT_Assignment();

  ABT_Assignment(const ABT_Assignment& from);

  inline ABT_Assignment& operator=(const ABT_Assignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_Assignment& default_instance();

  void Swap(ABT_Assignment* other);

  // implements Message ----------------------------------------------

  ABT_Assignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_Assignment& from);
  void MergeFrom(const ABT_Assignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ABT_Assignment)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_Assignment* default_instance_;
};
// -------------------------------------------------------------------

class ABT_CompoundAssignment : public ::google::protobuf::Message {
 public:
  ABT_CompoundAssignment();
  virtual ~ABT_CompoundAssignment();

  ABT_CompoundAssignment(const ABT_CompoundAssignment& from);

  inline ABT_CompoundAssignment& operator=(const ABT_CompoundAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_CompoundAssignment& default_instance();

  void Swap(ABT_CompoundAssignment* other);

  // implements Message ----------------------------------------------

  ABT_CompoundAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_CompoundAssignment& from);
  void MergeFrom(const ABT_CompoundAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ABT_Assignment assignments = 1;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 1;
  inline const ::ABT_Assignment& assignments(int index) const;
  inline ::ABT_Assignment* mutable_assignments(int index);
  inline ::ABT_Assignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::ABT_Assignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::ABT_Assignment >*
      mutable_assignments();

  // @@protoc_insertion_point(class_scope:ABT_CompoundAssignment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ABT_Assignment > assignments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_CompoundAssignment* default_instance_;
};
// -------------------------------------------------------------------

class ABT_Message_OK : public ::google::protobuf::Message {
 public:
  ABT_Message_OK();
  virtual ~ABT_Message_OK();

  ABT_Message_OK(const ABT_Message_OK& from);

  inline ABT_Message_OK& operator=(const ABT_Message_OK& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_Message_OK& default_instance();

  void Swap(ABT_Message_OK* other);

  // implements Message ----------------------------------------------

  ABT_Message_OK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_Message_OK& from);
  void MergeFrom(const ABT_Message_OK& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ABT_Assignment assignment = 1;
  inline bool has_assignment() const;
  inline void clear_assignment();
  static const int kAssignmentFieldNumber = 1;
  inline const ::ABT_Assignment& assignment() const;
  inline ::ABT_Assignment* mutable_assignment();
  inline ::ABT_Assignment* release_assignment();
  inline void set_allocated_assignment(::ABT_Assignment* assignment);

  // @@protoc_insertion_point(class_scope:ABT_Message.OK)
 private:
  inline void set_has_assignment();
  inline void clear_has_assignment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ABT_Assignment* assignment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_Message_OK* default_instance_;
};
// -------------------------------------------------------------------

class ABT_Message_NOGOOD : public ::google::protobuf::Message {
 public:
  ABT_Message_NOGOOD();
  virtual ~ABT_Message_NOGOOD();

  ABT_Message_NOGOOD(const ABT_Message_NOGOOD& from);

  inline ABT_Message_NOGOOD& operator=(const ABT_Message_NOGOOD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_Message_NOGOOD& default_instance();

  void Swap(ABT_Message_NOGOOD* other);

  // implements Message ----------------------------------------------

  ABT_Message_NOGOOD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_Message_NOGOOD& from);
  void MergeFrom(const ABT_Message_NOGOOD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ABT_CompoundAssignment nogood = 1;
  inline bool has_nogood() const;
  inline void clear_nogood();
  static const int kNogoodFieldNumber = 1;
  inline const ::ABT_CompoundAssignment& nogood() const;
  inline ::ABT_CompoundAssignment* mutable_nogood();
  inline ::ABT_CompoundAssignment* release_nogood();
  inline void set_allocated_nogood(::ABT_CompoundAssignment* nogood);

  // @@protoc_insertion_point(class_scope:ABT_Message.NOGOOD)
 private:
  inline void set_has_nogood();
  inline void clear_has_nogood();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ABT_CompoundAssignment* nogood_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_Message_NOGOOD* default_instance_;
};
// -------------------------------------------------------------------

class ABT_Message : public ::google::protobuf::Message {
 public:
  ABT_Message();
  virtual ~ABT_Message();

  ABT_Message(const ABT_Message& from);

  inline ABT_Message& operator=(const ABT_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABT_Message& default_instance();

  void Swap(ABT_Message* other);

  // implements Message ----------------------------------------------

  ABT_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ABT_Message& from);
  void MergeFrom(const ABT_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ABT_Message_OK OK;
  typedef ABT_Message_NOGOOD NOGOOD;

  typedef ABT_Message_MessageType MessageType;
  static const MessageType T_OK = ABT_Message_MessageType_T_OK;
  static const MessageType T_NOGOOD = ABT_Message_MessageType_T_NOGOOD;
  static const MessageType T_ADDLINK = ABT_Message_MessageType_T_ADDLINK;
  static const MessageType T_STOP = ABT_Message_MessageType_T_STOP;
  static inline bool MessageType_IsValid(int value) {
    return ABT_Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    ABT_Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    ABT_Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    ABT_Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return ABT_Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return ABT_Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return ABT_Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ABT_Message.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ABT_Message_MessageType type() const;
  inline void set_type(::ABT_Message_MessageType value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .ABT_Message.OK ok_data = 3;
  inline bool has_ok_data() const;
  inline void clear_ok_data();
  static const int kOkDataFieldNumber = 3;
  inline const ::ABT_Message_OK& ok_data() const;
  inline ::ABT_Message_OK* mutable_ok_data();
  inline ::ABT_Message_OK* release_ok_data();
  inline void set_allocated_ok_data(::ABT_Message_OK* ok_data);

  // optional .ABT_Message.NOGOOD nogood_data = 4;
  inline bool has_nogood_data() const;
  inline void clear_nogood_data();
  static const int kNogoodDataFieldNumber = 4;
  inline const ::ABT_Message_NOGOOD& nogood_data() const;
  inline ::ABT_Message_NOGOOD* mutable_nogood_data();
  inline ::ABT_Message_NOGOOD* release_nogood_data();
  inline void set_allocated_nogood_data(::ABT_Message_NOGOOD* nogood_data);

  // @@protoc_insertion_point(class_scope:ABT_Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ok_data();
  inline void clear_has_ok_data();
  inline void set_has_nogood_data();
  inline void clear_has_nogood_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::ABT_Message_OK* ok_data_;
  ::ABT_Message_NOGOOD* nogood_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protocols_2eproto();
  friend void protobuf_AssignDesc_protocols_2eproto();
  friend void protobuf_ShutdownFile_protocols_2eproto();

  void InitAsDefaultInstance();
  static ABT_Message* default_instance_;
};
// ===================================================================


// ===================================================================

// ABT_CommunicationProtocol_AgentIdentity

// required int32 id = 1;
inline bool ABT_CommunicationProtocol_AgentIdentity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ABT_CommunicationProtocol_AgentIdentity::id() const {
  return id_;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string host = 2;
inline bool ABT_CommunicationProtocol_AgentIdentity::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ABT_CommunicationProtocol_AgentIdentity::host() const {
  return *host_;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ABT_CommunicationProtocol_AgentIdentity::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* ABT_CommunicationProtocol_AgentIdentity::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 3;
inline bool ABT_CommunicationProtocol_AgentIdentity::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ABT_CommunicationProtocol_AgentIdentity::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ABT_CommunicationProtocol_AgentIdentity::port() const {
  return port_;
}
inline void ABT_CommunicationProtocol_AgentIdentity::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ABT_CommunicationProtocol

// required .ABT_CommunicationProtocol.MessageType type = 1;
inline bool ABT_CommunicationProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_CommunicationProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_CommunicationProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_CommunicationProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ABT_CommunicationProtocol_MessageType ABT_CommunicationProtocol::type() const {
  return static_cast< ::ABT_CommunicationProtocol_MessageType >(type_);
}
inline void ABT_CommunicationProtocol::set_type(::ABT_CommunicationProtocol_MessageType value) {
  assert(::ABT_CommunicationProtocol_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .ABT_CommunicationProtocol.AgentIdentity identity = 2;
inline bool ABT_CommunicationProtocol::has_identity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ABT_CommunicationProtocol::set_has_identity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ABT_CommunicationProtocol::clear_has_identity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ABT_CommunicationProtocol::clear_identity() {
  if (identity_ != NULL) identity_->::ABT_CommunicationProtocol_AgentIdentity::Clear();
  clear_has_identity();
}
inline const ::ABT_CommunicationProtocol_AgentIdentity& ABT_CommunicationProtocol::identity() const {
  return identity_ != NULL ? *identity_ : *default_instance_->identity_;
}
inline ::ABT_CommunicationProtocol_AgentIdentity* ABT_CommunicationProtocol::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) identity_ = new ::ABT_CommunicationProtocol_AgentIdentity;
  return identity_;
}
inline ::ABT_CommunicationProtocol_AgentIdentity* ABT_CommunicationProtocol::release_identity() {
  clear_has_identity();
  ::ABT_CommunicationProtocol_AgentIdentity* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void ABT_CommunicationProtocol::set_allocated_identity(::ABT_CommunicationProtocol_AgentIdentity* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
}

// repeated .ABT_CommunicationProtocol.AgentIdentity others = 3;
inline int ABT_CommunicationProtocol::others_size() const {
  return others_.size();
}
inline void ABT_CommunicationProtocol::clear_others() {
  others_.Clear();
}
inline const ::ABT_CommunicationProtocol_AgentIdentity& ABT_CommunicationProtocol::others(int index) const {
  return others_.Get(index);
}
inline ::ABT_CommunicationProtocol_AgentIdentity* ABT_CommunicationProtocol::mutable_others(int index) {
  return others_.Mutable(index);
}
inline ::ABT_CommunicationProtocol_AgentIdentity* ABT_CommunicationProtocol::add_others() {
  return others_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ABT_CommunicationProtocol_AgentIdentity >&
ABT_CommunicationProtocol::others() const {
  return others_;
}
inline ::google::protobuf::RepeatedPtrField< ::ABT_CommunicationProtocol_AgentIdentity >*
ABT_CommunicationProtocol::mutable_others() {
  return &others_;
}

// -------------------------------------------------------------------

// ABT_Assignment

// required int32 id = 1;
inline bool ABT_Assignment::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_Assignment::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_Assignment::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_Assignment::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ABT_Assignment::id() const {
  return id_;
}
inline void ABT_Assignment::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 value = 2;
inline bool ABT_Assignment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ABT_Assignment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ABT_Assignment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ABT_Assignment::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ABT_Assignment::value() const {
  return value_;
}
inline void ABT_Assignment::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ABT_CompoundAssignment

// repeated .ABT_Assignment assignments = 1;
inline int ABT_CompoundAssignment::assignments_size() const {
  return assignments_.size();
}
inline void ABT_CompoundAssignment::clear_assignments() {
  assignments_.Clear();
}
inline const ::ABT_Assignment& ABT_CompoundAssignment::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::ABT_Assignment* ABT_CompoundAssignment::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::ABT_Assignment* ABT_CompoundAssignment::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ABT_Assignment >&
ABT_CompoundAssignment::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::ABT_Assignment >*
ABT_CompoundAssignment::mutable_assignments() {
  return &assignments_;
}

// -------------------------------------------------------------------

// ABT_Message_OK

// required .ABT_Assignment assignment = 1;
inline bool ABT_Message_OK::has_assignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_Message_OK::set_has_assignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_Message_OK::clear_has_assignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_Message_OK::clear_assignment() {
  if (assignment_ != NULL) assignment_->::ABT_Assignment::Clear();
  clear_has_assignment();
}
inline const ::ABT_Assignment& ABT_Message_OK::assignment() const {
  return assignment_ != NULL ? *assignment_ : *default_instance_->assignment_;
}
inline ::ABT_Assignment* ABT_Message_OK::mutable_assignment() {
  set_has_assignment();
  if (assignment_ == NULL) assignment_ = new ::ABT_Assignment;
  return assignment_;
}
inline ::ABT_Assignment* ABT_Message_OK::release_assignment() {
  clear_has_assignment();
  ::ABT_Assignment* temp = assignment_;
  assignment_ = NULL;
  return temp;
}
inline void ABT_Message_OK::set_allocated_assignment(::ABT_Assignment* assignment) {
  delete assignment_;
  assignment_ = assignment;
  if (assignment) {
    set_has_assignment();
  } else {
    clear_has_assignment();
  }
}

// -------------------------------------------------------------------

// ABT_Message_NOGOOD

// required .ABT_CompoundAssignment nogood = 1;
inline bool ABT_Message_NOGOOD::has_nogood() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_Message_NOGOOD::set_has_nogood() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_Message_NOGOOD::clear_has_nogood() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_Message_NOGOOD::clear_nogood() {
  if (nogood_ != NULL) nogood_->::ABT_CompoundAssignment::Clear();
  clear_has_nogood();
}
inline const ::ABT_CompoundAssignment& ABT_Message_NOGOOD::nogood() const {
  return nogood_ != NULL ? *nogood_ : *default_instance_->nogood_;
}
inline ::ABT_CompoundAssignment* ABT_Message_NOGOOD::mutable_nogood() {
  set_has_nogood();
  if (nogood_ == NULL) nogood_ = new ::ABT_CompoundAssignment;
  return nogood_;
}
inline ::ABT_CompoundAssignment* ABT_Message_NOGOOD::release_nogood() {
  clear_has_nogood();
  ::ABT_CompoundAssignment* temp = nogood_;
  nogood_ = NULL;
  return temp;
}
inline void ABT_Message_NOGOOD::set_allocated_nogood(::ABT_CompoundAssignment* nogood) {
  delete nogood_;
  nogood_ = nogood;
  if (nogood) {
    set_has_nogood();
  } else {
    clear_has_nogood();
  }
}

// -------------------------------------------------------------------

// ABT_Message

// required .ABT_Message.MessageType type = 1;
inline bool ABT_Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABT_Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABT_Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABT_Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ABT_Message_MessageType ABT_Message::type() const {
  return static_cast< ::ABT_Message_MessageType >(type_);
}
inline void ABT_Message::set_type(::ABT_Message_MessageType value) {
  assert(::ABT_Message_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 id = 2;
inline bool ABT_Message::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ABT_Message::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ABT_Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ABT_Message::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ABT_Message::id() const {
  return id_;
}
inline void ABT_Message::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .ABT_Message.OK ok_data = 3;
inline bool ABT_Message::has_ok_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ABT_Message::set_has_ok_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ABT_Message::clear_has_ok_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ABT_Message::clear_ok_data() {
  if (ok_data_ != NULL) ok_data_->::ABT_Message_OK::Clear();
  clear_has_ok_data();
}
inline const ::ABT_Message_OK& ABT_Message::ok_data() const {
  return ok_data_ != NULL ? *ok_data_ : *default_instance_->ok_data_;
}
inline ::ABT_Message_OK* ABT_Message::mutable_ok_data() {
  set_has_ok_data();
  if (ok_data_ == NULL) ok_data_ = new ::ABT_Message_OK;
  return ok_data_;
}
inline ::ABT_Message_OK* ABT_Message::release_ok_data() {
  clear_has_ok_data();
  ::ABT_Message_OK* temp = ok_data_;
  ok_data_ = NULL;
  return temp;
}
inline void ABT_Message::set_allocated_ok_data(::ABT_Message_OK* ok_data) {
  delete ok_data_;
  ok_data_ = ok_data;
  if (ok_data) {
    set_has_ok_data();
  } else {
    clear_has_ok_data();
  }
}

// optional .ABT_Message.NOGOOD nogood_data = 4;
inline bool ABT_Message::has_nogood_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ABT_Message::set_has_nogood_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ABT_Message::clear_has_nogood_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ABT_Message::clear_nogood_data() {
  if (nogood_data_ != NULL) nogood_data_->::ABT_Message_NOGOOD::Clear();
  clear_has_nogood_data();
}
inline const ::ABT_Message_NOGOOD& ABT_Message::nogood_data() const {
  return nogood_data_ != NULL ? *nogood_data_ : *default_instance_->nogood_data_;
}
inline ::ABT_Message_NOGOOD* ABT_Message::mutable_nogood_data() {
  set_has_nogood_data();
  if (nogood_data_ == NULL) nogood_data_ = new ::ABT_Message_NOGOOD;
  return nogood_data_;
}
inline ::ABT_Message_NOGOOD* ABT_Message::release_nogood_data() {
  clear_has_nogood_data();
  ::ABT_Message_NOGOOD* temp = nogood_data_;
  nogood_data_ = NULL;
  return temp;
}
inline void ABT_Message::set_allocated_nogood_data(::ABT_Message_NOGOOD* nogood_data) {
  delete nogood_data_;
  nogood_data_ = nogood_data;
  if (nogood_data) {
    set_has_nogood_data();
  } else {
    clear_has_nogood_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ABT_CommunicationProtocol_MessageType>() {
  return ::ABT_CommunicationProtocol_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ABT_Message_MessageType>() {
  return ::ABT_Message_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocols_2eproto__INCLUDED
